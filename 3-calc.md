# 3-1. 符号なし演算と符号付き演算

コンピュータが直接理解できるのは2進数ですが、これを人間が直接理解するのは難しいため、わかりやすい形に変換する必要があります。この変換方法にはさまざまな種類があり、その選択は用途、精度、変換のしやすさなどによって異なります。高級言語では汎用性の高い方法が採用されていますが、アセンブリ言語では計算方法を変えるだけで、すべての方法を用いることが可能です。ただし、アセンブリ言語では「この数字はこの方法で扱う」というのをプログラマー自身が管理しなければならず、ミスが発生しやすいという特徴があります。

ここでは、アセンブリ言語で頻繁に使われる「符号付き整数」と「符号なし整数」について解説します。

## 数の表現方法
数を表現する方法にはいくつかの種類があります。ここではいくつかの代表的な方法を紹介します：

### 2進化10進法（BCD）:
10進数の各桁をそれぞれ4桁の2進数で表したものです。例えば、10進数の193はBCDで0001 1001 0011と表されます。この方法では、2進数の1010から1111までの数値は使用しません。

### 10進ゾーン形式:
10進数の1桁を1バイトの2進数で表す方法で、残りの4ビットを特定の数値で埋めます。最後の1桁の上位4ビットは符号を表します。

### 10進パック形式:
10進数の1桁を4ビットで表し、最後に符号を付けることで語長を短くしたものです。

### 固定小数点形式:
整数部と小数部に分けて表される方法です。

### 浮動小数点形式:
極端に大きな数や小さな数を扱うのに適しており、数値は指数を用いて表されます。

ここで紹介した数の表現方法の中で、アセンブリ言語では特に「符号なし整数」と「符号付き整数」の概念が重要です。これらの概念を理解することで、さまざまな数値演算を効率的に行うことが可能になります。

しかし、これらの複雑な数値表現方法を扱う場合は、アセンブリ言語よりも高級言語を使用した方がずっと簡単です。次のページでは、「符号なし整数」と「符号付き整数」についてさらに詳しく解説していきますので、少し気分転換をしてから挑戦してみてください。


## 整数について

では、整数について学びましょう。どんなプログラムにも整数は必ず登場します。整数は、小数よりシンプルであり、プログラミングで非常に重要です。

### 符号なし整数

最も基本的なのが符号なし整数です。8ビットの場合、2の8乗、つまり256個の異なる数値を表すことができます。これは0から255までの範囲です。16ビットならば0から65535まで、32ビットでは0から4294967295までの数値を表すことができます。

符号なし整数では、255に10を加えるような演算を行った場合、結果は自動的に該当ビット数に収まる範囲に丸め込まれます。例えば、8ビットでの255+10は265となりますが、8ビットでは表現できないため、結果は9（265の下8ビット）となります。

アセンブリ言語では、このような丸め込みが行われたかどうかをチェックする方法がありますが、C言語などの高級言語では直接的にはわかりません。そのため、必要に応じて演算を行う前に値が範囲を超えるかどうかをチェックする必要があります。

### 符号付き整数

符号付き整数では、最上位ビットを符号ビットとして使用します。0が正を、1が負を表します。そのため、8ビットの場合、正の数は0から127まで、負の数は-128から-1までを表すことができます。

負の数は「2の補数」として表されます。例えば-5の場合、+5（00000101）の1の補数（全ビットを反転）は11111010です。これに1を加えると11111011となり、これが-5の表現です。

2の補数を使用する利点は、加算だけで引き算が行えることです。例えば「15 - 3」を計算する場合、15（00001111）と-3（11111101）を加算すると、結果は12となります。これにより、引き算命令がない古いCPUでも、加算だけで引き算を行うことが可能でした。

しかし、符号付き整数でもオーバーフローは発生します。8ビットの場合、127（01111111）に1を加えると-128（10000000）になります。これは最大値からさらに加算を行うと最小値に跳ぶというオーバーフローの一例です。

コンピュータが数値を記憶する際、その値が正であるか負であるか、または小数であるかなどは関係ありません。大切なのは、プログラマがどのようにそれを扱うかです。高級言語では、変数に格納される値の型を宣言することで、多くの判断をコンパイラが代わりに行ってくれます。しかし、アセンブリ言語では、すべての判断をプログラマ自身が行う必要があります。

この入門では、まずは符号なし整数の扱い方から学びますが、基本を理解すれば符号付き整数の計算方法も容易に理解できるようになるでしょう。頑張りましょう。


# 3-2.足し算

NASMでの足し算について学びましょう。Linux環境でNASMを使用してアセンブリ言語プログラムを作成する際、基本的な算術演算は必須の知識です。ここでは、加算に使用する`add`命令に焦点を当てます。

### ADD命令

`add`命令は、2つのオペランドの和を計算し、その結果を第一オペランドに格納します。この命令は以下の形式を取ります：

```asm
add dest, src
```

- `dest`（目的地）: 加算結果が格納されるレジスタやメモリ位置です。
- `src`（ソース）: `dest`に加える値を指定するレジスタ、メモリ位置、または即値です。

加算操作では、`dest`と`src`のサイズが一致している必要があります。また、`add`命令の実行時には、オーバーフローフラグ（OF）、サインフラグ（SF）、ゼロフラグ（ZF）、キャリーフラグ（CF）など複数のフラグが影響を受ける可能性があります。

### 例: 数値の加算と表示

以下は、2つの数値を加算し、結果を画面に表示するシンプルなNASMプログラムの例です。Linuxでは、システムコールを使用して画面出力を行います。

```asm
section .data
DATA1   db 5              ; 数値5
DATA2   db 3              ; 数値3

section .text
    global _start

_start:
    mov dl, [DATA1]       ; DATA1の内容をdlに移動
    add dl, [DATA2]       ; DATA2の内容をdlに加算
    add dl, '0'           ; 数値をASCIIコードに変換

    ; 画面に結果を表示
    mov eax, 4            ; システムコール番号4（sys_write）
    mov ebx, 1            ; ファイル記述子1（標準出力）
    mov ecx, esp          ; スタックポインタをecxに移動
    push dl               ; dlをスタックにプッシュ
    mov edx, 1            ; メッセージの長さ
    int 0x80              ; システムコールを実行

    ; プログラムを終了
    mov eax, 1            ; システムコール番号1（sys_exit）
    xor ebx, ebx          ; 終了ステータス0
    int 0x80              ; システムコールを実行
```

このプログラムは、DATA1とDATA2の内容を加算し、その結果をASCIIコードに変換して画面に表示します。結果として、「8」という文字が表示されます。

このように、NASMを使ったプログラミングでは、基本的な算術演算とシステムコールを組み合わせて、さまざまな処理を実装することができます。


# 3-3.練習問題
DATA1とDATA2を足して、結果をANSに格納するプログラムを作成する
```asm
section .data
DATA1   dd 0EFFFFFFFh      ; 32ビットデータ、大きな数
DATA2   dd 1               ; 32ビットデータ、1
ANS     dd 0               ; 結果を格納するための領域、初期値は0

section .text
    global _start

_start:
    ________________       ; DATA1の内容をレジスタに移動
    ________________       ; DATA2の内容をそのレジスタに加算
    ________________       ; 加算結果をANSに格納

    ; プログラムを終了するシステムコール
    mov eax, 1             ; システムコール番号1（sys_exit）
    xor ebx, ebx           ; 終了ステータス0
    int 0x80               ; システムコールを実行

```
### ヒント
- 加算を行う前に、DATA1の内容を適切な32ビットレジスタにロードする必要があります。mov命令を使用してください。
- 次に、DATA2の内容をそのレジスタに加算します。ここでもadd命令が使われます。
- 最後に、加算結果をANSに格納するには、もう一度mov命令を使用して結果をメモリに書き戻します。

この穴埋め問題を解くことで、NASMにおける基本的なデータの加算と、結果の格納方法について学ぶことができます。




# 3-4.フラグ

フラグはCPUが各種計算や操作を行った後の状態を示すために用いられるビットです。これらはフラグレジスタ内で管理され、主にプログラムの流れを制御するために使われます。ここでは、初心者にもわかりやすいように、基本的なフラグの種類とその用途を簡単に説明します。

- CF（キャリーフラグ）: 加算で繰り上がりが発生したり、減算で桁借りが発生したりしたときにセットされます。「1」は発生したことを、「0」は発生しなかったことを意味します。エラーの有無を示す際にも使用されます。

- PF（パリティーフラグ）: 演算結果の最下位バイトに含まれる「1」の数が偶数の場合に「1」に、奇数の場合には「0」になります。一般的なプログラムではあまり使用されません。

- AF（補助キャリーフラグ）: 主にBCD（バイナリ符号化十進数）演算において使用されます。ここでは詳細な説明は省略します。

- ZF（ゼロフラグ）: 演算結果が0の場合に「1」に、0以外の場合には「0」になります。このフラグは条件分岐で頻繁に使用されます。

- SF（サインフラグ）: 演算結果が負の数（最上位ビットが「1」）である場合に「1」に、正の数（最上位ビットが「0」）の場合には「0」になります。

- IF（割り込み許可フラグ）: ハードウェア割り込みを許可するかどうかを制御します。「1」で許可し、「0」で禁止します。

- DF（ディレクションフラグ）: メモリの連続したデータを扱う命令（ストリング命令）で、データの処理方向を制御します。

- OF（オーバーフローフラグ）: 符号付き数値演算で結果がその数値の範囲を超えた場合に「1」になります。これは、計算結果が想定外に大きいか小さいかを示します。

これらのフラグは、プログラム内で条件分岐を行う際に重要な役割を果たします。例えば、ある条件下でのみ特定のコードを実行したい場合、フラグの状態をチェックしてその条件を満たしているかを判断します。プログラミングにおいて、これらのフラグを理解し、適切に使用することは、効率的で信頼性の高いコードを書く上で欠かせません。



# デバッガ を使って3.3練習問題の解答をフラグとALレジスタの変化をあわせて見てみる

デバッガーを使用してアセンブリ言語のコードをステップ実行し、レジスタの状態を確認する手順は、使用するデバッガーによって異なります。ここでは、一般的なLinux環境でよく使用されるGDB（GNU Debugger）を例に手順を説明します。


1. デバッガ(gdb)のインストール
```bash
sudo apt install gdb
```

2. コードのコンパイル
まず、デバッグ情報を含む実行可能ファイルを作成するために、アセンブリコードをコンパイルします。以下のコマンドは、NASMを使用してアセンブリ言語のプログラムをコンパイルし、その後ldを使ってリンクする一連の手順です。

```bash
nasm -f elf32 -g -F dwarf your_program.asm
ld -m elf_i386 -o your_program your_program.o
```
ここで、-gオプションはGDBで使用するデバッグ情報を生成するために必要です。-F dwarfオプションはデバッグ情報のフォーマットを指定します。

2. GDBでのプログラムの起動
次に、GDBを使用してプログラムを起動します。


input:
```
gdb ./your_program
```

output:
```
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./your_program...
```



3. ブレークポイントの設定
プログラムの実行を開始する前に、ブレークポイントを設定してプログラムの実行を一時停止します。これにより、特定の行や条件でプログラムの実行を止めて、レジスタの状態などを確認できます。

input:
```
(gdb) break _start
```

output:
```
Breakpoint 1 at 0x8049000: file your_program.asm, line 11.
```

Breakpoint 1, _start () at your_program.asm:11
11          mov al, [DATA1] ; DATA1の内容をalレジスタにロード
このコマンドは、_startラベル（プログラムの開始点）にブレークポイントを設定します。

4. プログラムの実行
ブレークポイントを設定したら、プログラムの実行を開始します。

input:
```
(gdb) run
```
output:
```
Starting program: /home/masahide/nasm/your_program
```

5. ステップ実行
プログラムがブレークポイントで停止したら、ステップ実行を行いながらレジスタの状態を確認します。

input:
```
(gdb) stepi
```
output:
```
12          mov bl, [DATA2] ; DATA3の内容をblレジスタにロード
```
または、より短いsiコマンドを使用します。このコマンドは、プログラムを1命令ずつ実行します。

6. レジスタの状態の確認
現在のレジスタの状態を確認するには、以下のコマンドを使用します。

input:
```
(gdb) info registers
```

これにより、すべてのレジスタの現在の値が表示されます。
output:
```
(gdb) info registers
eax            0xff                255
ecx            0x0                 0
edx            0x0                 0
ebx            0x0                 0
esp            0xffffcc00          0xffffcc00
ebp            0x0                 0x0
esi            0x0                 0
edi            0x0                 0
eip            0x8049005           0x8049005 <_start+5>
eflags         0x202               [ IF ]
cs             0x23                35
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x0                 0
gs             0x0                 0
```

7. プログラムの続行と終了
プログラムを終了するまでステップ実行を続けたい場合は、stepiコマンドを繰り返し使用します。プログラムの実行を続けるには、以下のコマンドを使用します。

```
(gdb) continue
```
プログラムの実行が完了したら、GDBを終了します。

```
(gdb) quit
```
以上が、GDBを使用してアセンブリ言語のプログラムをステップ実行し、レジスタの状態を確認する基本的な手順です。デバッガーを使うことで、プログラムの動作を詳細に理解し、バグを特定するのに役立ちます。

