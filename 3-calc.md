# 3-1. 符号なし演算と符号付き演算

コンピュータが直接理解できるのは2進数ですが、これを人間が直接理解するのは難しいため、わかりやすい形に変換する必要があります。この変換方法にはさまざまな種類があり、その選択は用途、精度、変換のしやすさなどによって異なります。高級言語では汎用性の高い方法が採用されていますが、アセンブリ言語では計算方法を変えるだけで、すべての方法を用いることが可能です。ただし、アセンブリ言語では「この数字はこの方法で扱う」というのをプログラマー自身が管理しなければならず、ミスが発生しやすいという特徴があります。

ここでは、アセンブリ言語で頻繁に使われる「符号付き整数」と「符号なし整数」について解説します。

## 数の表現方法
数を表現する方法にはいくつかの種類があります。ここではいくつかの代表的な方法を紹介します：

### 2進化10進法（BCD）:
10進数の各桁をそれぞれ4桁の2進数で表したものです。例えば、10進数の193はBCDで0001 1001 0011と表されます。この方法では、2進数の1010から1111までの数値は使用しません。

### 10進ゾーン形式:
10進数の1桁を1バイトの2進数で表す方法で、残りの4ビットを特定の数値で埋めます。最後の1桁の上位4ビットは符号を表します。

### 10進パック形式:
10進数の1桁を4ビットで表し、最後に符号を付けることで語長を短くしたものです。

### 固定小数点形式:
整数部と小数部に分けて表される方法です。

### 浮動小数点形式:
極端に大きな数や小さな数を扱うのに適しており、数値は指数を用いて表されます。

ここで紹介した数の表現方法の中で、アセンブリ言語では特に「符号なし整数」と「符号付き整数」の概念が重要です。これらの概念を理解することで、さまざまな数値演算を効率的に行うことが可能になります。

しかし、これらの複雑な数値表現方法を扱う場合は、アセンブリ言語よりも高級言語を使用した方がずっと簡単です。次のページでは、「符号なし整数」と「符号付き整数」についてさらに詳しく解説していきますので、少し気分転換をしてから挑戦してみてください。


## 整数について

では、整数について学びましょう。どんなプログラムにも整数は必ず登場します。整数は、小数よりシンプルであり、プログラミングで非常に重要です。

### 符号なし整数

最も基本的なのが符号なし整数です。8ビットの場合、2の8乗、つまり256個の異なる数値を表すことができます。これは0から255までの範囲です。16ビットならば0から65535まで、32ビットでは0から4294967295までの数値を表すことができます。

符号なし整数では、255に10を加えるような演算を行った場合、結果は自動的に該当ビット数に収まる範囲に丸め込まれます。例えば、8ビットでの255+10は265となりますが、8ビットでは表現できないため、結果は9（265の下8ビット）となります。

アセンブリ言語では、このような丸め込みが行われたかどうかをチェックする方法がありますが、C言語などの高級言語では直接的にはわかりません。そのため、必要に応じて演算を行う前に値が範囲を超えるかどうかをチェックする必要があります。

### 符号付き整数

符号付き整数では、最上位ビットを符号ビットとして使用します。0が正を、1が負を表します。そのため、8ビットの場合、正の数は0から127まで、負の数は-128から-1までを表すことができます。

負の数は「2の補数」として表されます。例えば-5の場合、+5（00000101）の1の補数（全ビットを反転）は11111010です。これに1を加えると11111011となり、これが-5の表現です。

2の補数を使用する利点は、加算だけで引き算が行えることです。例えば「15 - 3」を計算する場合、15（00001111）と-3（11111101）を加算すると、結果は12となります。これにより、引き算命令がない古いCPUでも、加算だけで引き算を行うことが可能でした。

しかし、符号付き整数でもオーバーフローは発生します。8ビットの場合、127（01111111）に1を加えると-128（10000000）になります。これは最大値からさらに加算を行うと最小値に跳ぶというオーバーフローの一例です。

コンピュータが数値を記憶する際、その値が正であるか負であるか、または小数であるかなどは関係ありません。大切なのは、プログラマがどのようにそれを扱うかです。高級言語では、変数に格納される値の型を宣言することで、多くの判断をコンパイラが代わりに行ってくれます。しかし、アセンブリ言語では、すべての判断をプログラマ自身が行う必要があります。

この入門では、まずは符号なし整数の扱い方から学びますが、基本を理解すれば符号付き整数の計算方法も容易に理解できるようになるでしょう。頑張りましょう。


# 3-2.足し算

NASMでの足し算について学びましょう。Linux環境でNASMを使用してアセンブリ言語プログラムを作成する際、基本的な算術演算は必須の知識です。ここでは、加算に使用する`add`命令に焦点を当てます。

### ADD命令

`add`命令は、2つのオペランドの和を計算し、その結果を第一オペランドに格納します。この命令は以下の形式を取ります：

```asm
add dest, src
```

- `dest`（目的地）: 加算結果が格納されるレジスタやメモリ位置です。
- `src`（ソース）: `dest`に加える値を指定するレジスタ、メモリ位置、または即値です。

加算操作では、`dest`と`src`のサイズが一致している必要があります。また、`add`命令の実行時には、オーバーフローフラグ（OF）、サインフラグ（SF）、ゼロフラグ（ZF）、キャリーフラグ（CF）など複数のフラグが影響を受ける可能性があります。

### 例: 数値の加算と表示

以下は、2つの数値を加算し、結果を画面に表示するシンプルなNASMプログラムの例です。Linuxでは、システムコールを使用して画面出力を行います。

```asm
section .data
DATA1   db 5              ; 数値5
DATA2   db 3              ; 数値3

section .text
    global _start

_start:
    mov dl, [DATA1]       ; DATA1の内容をdlに移動
    add dl, [DATA2]       ; DATA2の内容をdlに加算
    add dl, '0'           ; 数値をASCIIコードに変換

    ; 画面に結果を表示
    mov eax, 4            ; システムコール番号4（sys_write）
    mov ebx, 1            ; ファイル記述子1（標準出力）
    mov ecx, esp          ; スタックポインタをecxに移動
    push dl               ; dlをスタックにプッシュ
    mov edx, 1            ; メッセージの長さ
    int 0x80              ; システムコールを実行

    ; プログラムを終了
    mov eax, 1            ; システムコール番号1（sys_exit）
    xor ebx, ebx          ; 終了ステータス0
    int 0x80              ; システムコールを実行
```

このプログラムは、DATA1とDATA2の内容を加算し、その結果をASCIIコードに変換して画面に表示します。結果として、「8」という文字が表示されます。

このように、NASMを使ったプログラミングでは、基本的な算術演算とシステムコールを組み合わせて、さまざまな処理を実装することができます。


# 3-3.練習問題
DATA1とDATA2を足して、結果をANSに格納するプログラムを作成する
```asm
section .data
DATA1   dd 0EFFFFFFFh      ; 32ビットデータ、大きな数
DATA2   dd 1               ; 32ビットデータ、1
ANS     dd 0               ; 結果を格納するための領域、初期値は0

section .text
    global _start

_start:
    ________________       ; DATA1の内容をレジスタに移動
    ________________       ; DATA2の内容をそのレジスタに加算
    ________________       ; 加算結果をANSに格納

    ; プログラムを終了するシステムコール
    mov eax, 1             ; システムコール番号1（sys_exit）
    xor ebx, ebx           ; 終了ステータス0
    int 0x80               ; システムコールを実行

```
### ヒント
- 加算を行う前に、DATA1の内容を適切な32ビットレジスタにロードする必要があります。mov命令を使用してください。
- 次に、DATA2の内容をそのレジスタに加算します。ここでもadd命令が使われます。
- 最後に、加算結果をANSに格納するには、もう一度mov命令を使用して結果をメモリに書き戻します。

この穴埋め問題を解くことで、NASMにおける基本的なデータの加算と、結果の格納方法について学ぶことができます。
